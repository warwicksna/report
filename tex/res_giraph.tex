\subsection{Giraph}
Giraph is a graph processing framework, inspired by Pregel, initially developed at Yahoo!. It has since become an Apache Incubator project\footnote{\url{http://incubator.apache.org/giraph/}}. Giraph is still under development, with more features being added and improved.

\subsubsection{Pregel}
Pregel is a framework developed at Google for large-scale graph processing \cite{pregel}.

A Pregel computation executes as a series of parallel supersteps, similar in style to the Bulk Synchronous Parallel computation model described in \cite{bsp}. At each superstep, each active vertex performs some computation, which could modify the state of itself, its outgoing edges or send messages to other vertices to be received in the next superstep. An active vertex can also $VoteToHalt$, which stops this vertex it from performing any extra computation whilst the algorithm is being executed, unless the inactive vertex receives a message, in which case it becomes active again to process the messages it has received. When all vertices have voted to halt, the algorithm terminates.

The use of an underlying Bulk Synchonous Parallel model provides the Pregel framework with a simple way to model iteration of graph algorithms, and also provides a simple way to achieve a fault tolerant system. Each superstep in the execution of a Pregel program provides a natural barrier to synchronise each vertex's computation. If a worker fails to communicate with the master within a defined time period, the master assumes that the worker has failed, and can restart the program from the checkpoint made at the previous superstep completion, re-partitioning the graph if the failed worker is still unavailable.

The Pregel framework also provides some extra useful features called combiners and aggregators. A combiner groups together a series of messages from one vertex to another into a single message containing the result of an operation on these messages. This is to reduce the overhead incurred from sending many messages and then performing the same operation at the receiving vertex. An aggregator is a global data construct, which each vertex has access to its value at each superstep, and the value can be updated at the end of each superstep in time for the next superstep. Aggregators can be used to store information about a graph, such as the number of edges in the graph.

Pregel also supports mutations of the graph an algorithm is being executed on. There are two types of mutations, global and local. A global mutation includes the addition and removal of vertices, as these can affect more that just a single vertex. Global mutations are partially ordered, and the effects of these mutations are seen in the next superstep. A local mutation includes a single vertex adding or removing an edge to another vertex. As these only affect the vertex which is performing these mutations, they happen immediately without any conflicts.

\lstset{language=C++,caption={PageRank algorithm in Pregel \cite{pregel}},label=pregelpagerank,tabsize=2,breaklines=true,breakatwhitespace=true,frame=single}
\begin{lstlisting}
class PageRankVertex
			: public Vertex<double, void, double> {
	public :	
		virtual void Compute(MessageIterator* msgs) {
			if (superstep() >= 1) {
				double sum = 0;
				for(; !msgs->Done(); msgs->Next())
					sum += msgs->Value();
				*MutableValue() = 0.15 / NumVertices() + 0.85 * sum;
			}
			
			if (superstep() < 30) {
				const int64 n = GetOutEdgeIterator().size();
				SendMessageToAllNeighbors(GetValue() / n);
			} else {
				VoteToHalt();
			}
		}
};					
\end{lstlisting} 

\subsubsection{Giraph}
Giraph is a framework which was designed for large-scale graph processing on Hadoop. There are a number of existing solutions to achieve large-scale graph processing, however these also have their own problems.

Graph algorithms can be executed as a sequence of map-reduce jobs in Hadoop, but this suffers from the overheads of repeatedly launching these jobs and the map-reduce model is not a good fit for graph algorithms. Pregel itself has problems in that it requires a separate computing infrastructure, and is also unavailable to non-Google employees. The Message Passage Interface can also be used for graph processing, however it lacks any form of fault tolerance and is consider too generic \cite{giraphtalk}.

\lstset{language=Java,caption={PageRank algorithm in Giraph \cite{giraphtalk}},label=giraphpagerank,tabsize=2,breaklines=true,breakatwhitespace=true,frame=single}
\begin{lstlisting}
public class SimplePageRankVertex extends HadoopVertex<LongWritable, DoubleWritable, FloatWritable, DoubleWritable> {

	public void compute(Iterator<DoubleWritable> msgIterator) {
		double sum = 0;
		
		while (msgIterator.hasNext()) {
			sum += msgIterator.next().get();
		}
		
		setVertexValue(new DoubleWritable((0.15f/getNumVertices()) + 0.85f * sum);
		
		if (getSuperstep() < 30) {
			long edges = getOutEdgeIterator().size();
			
			sendMsgToAllEdges(new DoubleWritable(getVertexValue().get() / edges));
		} else {
			voteToHalt();
		}
	}
}					
\end{lstlisting}