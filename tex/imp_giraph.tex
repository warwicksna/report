\subsection{Giraph}
Giraph programs all follow a similar construct. As a minimum, the \verb/compute()/ method needs to be implemented because this is where the algorithms are executed on each vertex within the graph.

\lstset{language=Java,caption={Basic structure of a Giraph program},label=lst:giraphstructure,tabsize=2,breaklines=true,breakatwhitespace=true,frame=single}
\begin{lstlisting}[float]
public class Vertex<I, V, E, M> {
	public void compute(Iterator<M> msgIterator) {}
	
	public static class VertexInputFormat {}
	
	public static class VertexReader {}
	
	public static class VertexOutputFormat {}
	
	public static class VertexWriter {}
	
	public int run(String[] argArray) {}
	
	public static void main (String[] args) {}
}						
\end{lstlisting}

As explained in Section \ref{sec:res_giraph}, a Giraph program is executed as a Hadoop job. This means that in addition to the \verb/compute()/ method being complete, other classes are required to read in and write out the graphs before and after processing to the HDFS.

Following on from the shortest paths example \cite{giraphexample} provided by Apache for Giraph, the decision was taken to use the same JSON\footnote{JavaScript Object Notation \url{http://www.json.org/}} style format to store the graphs as adjacency list structures in the HDFS.

\lstset{language=C,caption={JSON adjacency list representation of a graph},label=lst:json,tabsize=2,breaklines=true,breakatwhitespace=true,frame=single}
\begin{lstlisting}[float]
[1, 0, [[2, 1], [3, 1]]]
[2, 0, [[1, 1], [3, 1]]]
[3, 0, [[1, 1], [2, 1], [4, 1]]]
[4, 0, [[3, 1], [5, 1], [6, 1]]]
[5, 0, [[4, 1], [6, 1]]]
[6, 0, [[4, 1], [5, 1]]]
\end{lstlisting}

Listing \ref{lst:json} represents the graph shown in Figure \ref{fig:json}. The adjacency list representation can be split into three parts, the vertex ID, the vertex value, and a list edges this vertex connects to. As explained in Section \ref{sec:res_giraph}, Giraph only processes directed graphs, hence the need to represent edges in both directions to simulate an undirected graph. The use of this JSON format also maps quite neatly onto the structure of the \verb/Vertex/ class representing a vertex within Giraph, as the vertex ID, vertex value and edges are all easily obtainable.

\begin{figure}[htbp]
  \centering
    \includegraphics{./img/json}
  \caption{The graph represented by Listing \ref{lst:json}}
  \label{fig:json}
\end{figure}

\lstset{language=Java,caption={Giraph JSON-style input \cite{giraphexample} },label=lst:giraphvertexinput,tabsize=2,breaklines=true,breakatwhitespace=true,frame=single}
\begin{lstlisting}[float]
public static class SimpleShortestPathsVertexInputFormat extends
        TextVertexInputFormat<LongWritable, DoubleWritable, FloatWritable> {
    @Override
    public VertexReader<LongWritable, DoubleWritable, FloatWritable>
            createVertexReader(InputSplit split,
                               TaskAttemptContext context)
                               throws IOException {
        return new SimpleShortestPathsVertexReader(
            textInputFormat.createRecordReader(split, context));
    }
}
\end{lstlisting}

\lstset{language=Java,caption={Giraph JSON-style input \cite{giraphexample} },label=lst:giraphvertexreader,tabsize=2,breaklines=true,breakatwhitespace=true,frame=single,showstringspaces=false}
\begin{lstlisting}[float]
public static class SimpleShortestPathsVertexReader extends
        TextVertexReader<LongWritable, DoubleWritable, FloatWritable> {

    public SimpleShortestPathsVertexReader(
            RecordReader<LongWritable, Text> lineRecordReader) {
        super(lineRecordReader);
    }
    @Override
    public boolean next(MutableVertex<LongWritable,
                        DoubleWritable, FloatWritable, ?> vertex)
            throws IOException, InterruptedException {
        if (!getRecordReader().nextKeyValue()) {
            return false;
        }
        Text line = getRecordReader().getCurrentValue();
        try {
            JSONArray jsonVertex = new JSONArray(line.toString());
            vertex.setVertexId(
                new LongWritable(jsonVertex.getLong(0)));
            vertex.setVertexValue(
                new DoubleWritable(jsonVertex.getDouble(1)));
            JSONArray jsonEdgeArray = jsonVertex.getJSONArray(2);
            for (int i = 0; i < jsonEdgeArray.length(); ++i) {
                JSONArray jsonEdge = jsonEdgeArray.getJSONArray(i);
                Edge<LongWritable, FloatWritable> edge =
                    new Edge<LongWritable, FloatWritable>(
                        new LongWritable(jsonEdge.getLong(0)),
                        new FloatWritable((float) jsonEdge.getDouble(1)));
                vertex.addEdge(edge);
            }
        } catch (JSONException e) {
            throw new IllegalArgumentException(
                ``next: Couldn't get vertex from line `` + line, e);
        }
        return true;
}}
\end{lstlisting}

\lstset{language=Java,caption={Giraph JSON-style input \cite{giraphexample} },label=lst:giraphvertexoutput,tabsize=2,breaklines=true,breakatwhitespace=true,frame=single,showstringspaces=false}
\begin{lstlisting}[float]
public static class SimpleShortestPathsVertexOutputFormat extends
        TextVertexOutputFormat<LongWritable, DoubleWritable,
        FloatWritable> {

    @Override
    public VertexWriter<LongWritable, DoubleWritable, FloatWritable>
            createVertexWriter(TaskAttemptContext context)
            throws IOException, InterruptedException {
        RecordWriter<Text, Text> recordWriter =
            textOutputFormat.getRecordWriter(context);
        return new SimpleShortestPathsVertexWriter(recordWriter);
    }
}
\end{lstlisting}

\lstset{language=Java,caption={Giraph JSON-style input \cite{giraphexample} },label=lst:giraphvertexwriter,tabsize=2,breaklines=true,breakatwhitespace=true,frame=single,showstringspaces=false}
\begin{lstlisting}[float]
public static class SimpleShortestPathsVertexWriter extends
        TextVertexWriter<LongWritable, DoubleWritable, FloatWritable> {
    public SimpleShortestPathsVertexWriter(
            RecordWriter<Text, Text> lineRecordWriter) {
        super(lineRecordWriter);
    }

    @Override
    public void writeVertex(BasicVertex<LongWritable, DoubleWritable,
                            FloatWritable, ?> vertex)
            throws IOException, InterruptedException {
        JSONArray jsonVertex = new JSONArray();
        try {
            jsonVertex.put(vertex.getVertexId().get());
            jsonVertex.put(vertex.getVertexValue().get());
            JSONArray jsonEdgeArray = new JSONArray();
            for (Edge<LongWritable, FloatWritable> edge :
                    vertex.getOutEdgeMap().values()) {
                JSONArray jsonEdge = new JSONArray();
                jsonEdge.put(edge.getDestVertexId().get());
                jsonEdge.put(edge.getEdgeValue().get());
                jsonEdgeArray.put(jsonEdge);
            }
            jsonVertex.put(jsonEdgeArray);
        } catch (JSONException e) {
            throw new IllegalArgumentException(
                "writeVertex: Couldn't write vertex " + vertex);
        }
        getRecordWriter().write(new Text(jsonVertex.toString()), null);
    }
}
\end{lstlisting}